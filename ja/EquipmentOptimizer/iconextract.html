<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Item Detect + Hash + Rarity + OCR</title>
<style>
body { font-family: sans-serif; margin: 20px; }
canvas { border: 1px solid #aaa; }
#result { display: flex; flex-wrap: wrap; gap: 12px; margin-top: 10px; }
.item { text-align: center; cursor: pointer; }
.item canvas {
  width: 64px; height: 64px;
  border: 1px solid #666;
  image-rendering: pixelated;
}
.label { font-size: 12px; white-space: nowrap; }
pre {
  background: #f5f5f5;
  padding: 10px;
  max-height: 300px;
  overflow: auto;
}
.badge {
  display: inline-block;
  font-size: 11px;
  padding: 2px 6px;
  border: 1px solid #ccc;
  border-radius: 999px;
  margin-left: 6px;
}
.debug-block {
  display: inline-flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
}
.debug-title {
  font-size: 12px;
  opacity: 0.7;
}
#ocrDebug {
  display: flex;
  gap: 16px;
  align-items: center;
  flex-wrap: wrap;
}
#ocrDebug canvas {
  border: 1px solid #bbb;
  image-rendering: pixelated;
  background: #fff;
}
.small {
  font-size: 11px;
  opacity: 0.75;
}
</style>
</head>
<body>

<h2>アイテム判別 + レアリティ判定 + 数量OCR PoC</h2>

<input type="file" id="file" accept="image/*">
<p>または Ctrl+V で画像貼り付け</p>

<div class="small">
  OCR初回はWASM読込で少し時間がかかります。数量領域が合わない場合は下の「OCR切り出し設定」を調整してください。
  <span id="ocrStatus" class="badge">OCR: not loaded</span>
</div>

<canvas id="src"></canvas>

<h3>検出アイテム</h3>
<div id="result"></div>

<h3>OCRデバッグ表示</h3>
<div id="ocrDebug">
  <div class="debug-block">
    <div class="debug-title">crop</div>
    <canvas id="ocrCrop"></canvas>
  </div>
  <div class="debug-block">
    <div class="debug-title">bin</div>
    <canvas id="ocrBin"></canvas>
  </div>
  <div class="debug-block">
    <div class="debug-title">threshold</div>
    <div id="ocrThreshold" class="badge">-</div>
  </div>
</div>

<h3>登録DB（JSON）</h3>
<pre id="dbview"></pre>

<!-- tesseract.js (WASM) -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

<script>
const srcCanvas = document.getElementById("src");
const srcCtx = srcCanvas.getContext("2d");
const result = document.getElementById("result");
const dbview = document.getElementById("dbview");
const ocrStatus = document.getElementById("ocrStatus");
const ocrCropCanvas = document.getElementById("ocrCrop");
const ocrBinCanvas = document.getElementById("ocrBin");
const ocrThresholdLabel = document.getElementById("ocrThreshold");

const ITEM_DB_KEY = "item_hash_db";
const RARITY_DB_KEY = "rarity_color_db";

function loadDB(){
  const storedItems  = localStorage.getItem(ITEM_DB_KEY);
  const storedRarity = localStorage.getItem(RARITY_DB_KEY);

  const itemDB = storedItems
    ? JSON.parse(storedItems)
    : structuredClone(DEFAULT_DB.items);

  const rarityDB = storedRarity
    ? JSON.parse(storedRarity)
    : structuredClone(DEFAULT_DB.rarity);

  return { itemDB, rarityDB };
}

const { itemDB, rarityDB } = loadDB();

const RARITIES = ["Common","Uncommon","Rare","Epic","Legendary"];

const DEFAULT_DB = {
  items: {
    "Wood": "0000000000001100001110000111000011110010110111001101100011111111",
    "Rope": "0000011000111100010010001111010011110000000000001000000100011111",
    "Fabric": "0000000000111100011111100111100101111000111100000000011111111111",
    "Feather": "0000000000000111000101110001111101001111001000001100010011101111",
    "Leather": "0111001111110000111110110001100001011001010000010000000000001111",
    "Stone": "0000000000011110011111101111000001100000000010001000000010111111"
  },
  rarity: {
    "Common":     { r:110.75, g:110,    b:110.16666666666667 },
    "Uncommon":   { r:94.91666666666667, g:133.91666666666666, b:106.66666666666667 },
    "Rare":       { r:78.83333333333333, g:96.75,  b:131.58333333333334 },
    "Epic":       { r:105.75, g:97.66666666666667, b:136.5 },
    "Legendary":  { r:135,    g:111.66666666666667, b:48.916666666666664 }
  }
};

// ---- OCR: crop settings (tune here) ----
// 右下を想定：幅を少し広めに
const OCR_CROP = {
  x: 0.52,   // 左上X（0-1）
  y: 0.65,   // 左上Y（0-1）
  w: 0.46,   // 幅（0-1）
  h: 0.32    // 高さ（0-1）
};
// 二値化の調整値（ローカル平均との差分）
const OCR_BIN_OFFSET = 10;
const OCR_BIN_WINDOW = 15; // 奇数推奨

// OCR判定を軽くする（小さすぎると精度低下するので注意）
const OCR_RESIZE_W = 180; // OCR前に横幅をこれに拡大/縮小
const OCR_COMMON_VAR_THRESHOLD = 30;
// --------------------------------------

updateDBView();

// ---------- OCR Worker (single instance) ----------
let ocrWorker = null;
let ocrReady = false;
let ocrQueue = Promise.resolve();

async function ensureOcrWorker(){
  if (ocrReady) return;

  if (!ocrWorker) {
    ocrStatus.textContent = "OCR: loading...";
    // logger を渡さない（←重要）
    ocrWorker = await Tesseract.createWorker();
  }

  // v5 では必須
  await ocrWorker.load();
  await ocrWorker.loadLanguage("eng");
  await ocrWorker.initialize("eng");

  await ocrWorker.setParameters({
    tessedit_char_whitelist: "0123456789",
    tessedit_pageseg_mode: Tesseract.PSM.SINGLE_LINE
  });

  ocrReady = true;
  ocrStatus.textContent = "OCR: ready";
}



// キューで直列実行（同時実行すると重い/不安定になりがち）
function enqueueOcr(task){
  ocrQueue = ocrQueue.then(task).catch(err => {
    console.error(err);
  });
  return ocrQueue;
}

// ---------- Image Load ----------
document.getElementById("file").onchange = e => {
  loadImage(URL.createObjectURL(e.target.files[0]));
};

document.addEventListener("paste", e => {
  for (const item of e.clipboardData.items) {
    if (item.type.startsWith("image")) {
      loadImage(URL.createObjectURL(item.getAsFile()));
    }
  }
});

function loadImage(url){
  const img=new Image();
  img.onload=()=>{
    srcCanvas.width=img.width;
    srcCanvas.height=img.height;
    srcCtx.drawImage(img,0,0);
    detectFrames();
  };
  img.src=url;
}

// ---------- aHash ----------
function normalize(canvas){
  const c=document.createElement("canvas");
  c.width=c.height=32;
  const ctx=c.getContext("2d");
  const m=canvas.width*0.15;
  ctx.drawImage(canvas,m,m,canvas.width-m*2,canvas.height-m*2,0,0,32,32);
  return c;
}

function aHash(canvas){
  const c=document.createElement("canvas");
  c.width=c.height=8;
  const ctx=c.getContext("2d");
  ctx.drawImage(canvas,0,0,8,8);
  const d=ctx.getImageData(0,0,8,8).data;
  let g=[];
  for(let i=0;i<d.length;i+=4) g.push((d[i]+d[i+1]+d[i+2])/3);
  const avg=g.reduce((a,b)=>a+b)/64;
  return g.map(v=>v>avg?1:0).join("");
}

function hamming(a,b){
  let d=0;
  for(let i=0;i<a.length;i++) if(a[i]!==b[i]) d++;
  return d;
}

function identifyItem(hash){
  let best=null,score=999;
  for(const k in itemDB){
    const d=hamming(hash,itemDB[k]);
    if(d<score){score=d;best=k;}
  }
  return score<=12?best:null;
}

// ---------- Rarity Color ----------
function sampleFrameColor(canvas){
  const ctx = canvas.getContext("2d");
  const w = canvas.width, h = canvas.height;

  const pad = Math.max(2, Math.floor(Math.min(w,h) * 0.06));
  const xs = [pad, w/2|0, w-pad-1];
  const ys = [pad, h/2|0, h-pad-1];

  const pts = [];
  for (const x of xs) { pts.push([x, pad]); pts.push([x, h-pad-1]); }
  for (const y of ys) { pts.push([pad, y]); pts.push([w-pad-1, y]); }

  let r=0,g=0,b=0;
  for (const [x,y] of pts){
    const d = ctx.getImageData(x,y,1,1).data;
    r += d[0]; g += d[1]; b += d[2];
  }
  const n = pts.length;
  return { r:r/n, g:g/n, b:b/n };
}

function colorDist(a,b){
  return Math.abs(a.r-b.r)+Math.abs(a.g-b.g)+Math.abs(a.b-b.b);
}

function identifyRarity(color){
  // 最も近い色を選ぶ（全比較）
  let best=null,score=999;
  for(const r in rarityDB){
    const d=colorDist(color,rarityDB[r]);
    if(d<score){score=d;best=r;}
  }
  return score<120?best:null;
}

// ---------- OCR helpers ----------
function cropNumberArea(itemCanvas){
  const w = itemCanvas.width, h = itemCanvas.height;
  const rx = Math.floor(w * OCR_CROP.x);
  const ry = Math.floor(h * OCR_CROP.y);
  const rw = Math.max(1, Math.floor(w * OCR_CROP.w));
  const rh = Math.max(1, Math.floor(h * OCR_CROP.h));

  const c = document.createElement("canvas");
  c.width = rw;
  c.height = rh;
  c.getContext("2d").drawImage(itemCanvas, rx, ry, rw, rh, 0, 0, rw, rh);
  return c;
}

function prepareOcrCanvas(itemCanvas){
  const crop = cropNumberArea(itemCanvas);
  const w = crop.width, h = crop.height;
  const scale = OCR_RESIZE_W / w;
  const tw = OCR_RESIZE_W;
  const th = Math.max(1, Math.floor(h * scale));

  const c = document.createElement("canvas");
  c.width = tw;
  c.height = th;
  const ctx = c.getContext("2d");
  ctx.drawImage(crop, 0, 0, tw, th);

  const img = ctx.getImageData(0,0,tw,th);
  const d = img.data;
  const gray = new Uint8Array(tw * th);
  let min = 255;
  let max = 0;
  for(let i=0;i<d.length;i+=4){
    const g = (d[i]+d[i+1]+d[i+2]) / 3;
    const gv = g | 0;
    gray[i/4] = gv;
    if (gv < min) min = gv;
    if (gv > max) max = gv;
  }
  const range = Math.max(1, max - min);
  for (let i = 0; i < gray.length; i++) {
    gray[i] = ((gray[i] - min) * 255 / range) | 0;
  }

  return { canvas: c, gray, width: tw, height: th };
}

function binarizeFromGray(gray, w, h){
  const bin = adaptiveThreshold(gray, w, h, OCR_BIN_WINDOW, OCR_BIN_OFFSET);
  const c = document.createElement("canvas");
  c.width = w;
  c.height = h;
  const ctx = c.getContext("2d");
  const img = ctx.createImageData(w, h);
  const d = img.data;
  for(let i=0;i<bin.length;i++){
    const v = bin[i];
    const p = i * 4;
    d[p]=d[p+1]=d[p+2]=v;
    d[p+3]=255;
  }
  ctx.putImageData(img,0,0);
  return { canvas: c, threshold: `adaptive(${OCR_BIN_WINDOW},-${OCR_BIN_OFFSET})` };
}

function adaptiveThreshold(gray, w, h, windowSize, offset){
  const size = windowSize | 0;
  const half = Math.max(1, size >> 1);
  const integral = new Uint32Array((w + 1) * (h + 1));
  for (let y = 1; y <= h; y++) {
    let rowSum = 0;
    for (let x = 1; x <= w; x++) {
      const idx = (y - 1) * w + (x - 1);
      rowSum += gray[idx];
      integral[y * (w + 1) + x] = integral[(y - 1) * (w + 1) + x] + rowSum;
    }
  }
  const out = new Uint8Array(w * h);
  for (let y = 0; y < h; y++) {
    const y1 = Math.max(0, y - half);
    const y2 = Math.min(h - 1, y + half);
    for (let x = 0; x < w; x++) {
      const x1 = Math.max(0, x - half);
      const x2 = Math.min(w - 1, x + half);
      const A = integral[y1 * (w + 1) + x1];
      const B = integral[y1 * (w + 1) + (x2 + 1)];
      const C = integral[(y2 + 1) * (w + 1) + x1];
      const D = integral[(y2 + 1) * (w + 1) + (x2 + 1)];
      const area = (x2 - x1 + 1) * (y2 - y1 + 1);
      const mean = (D - B - C + A) / area;
      const idx = y * w + x;
      out[idx] = gray[idx] > (mean - offset) ? 255 : 0;
    }
  }
  return out;
}

function computeCommonMask(grays, w, h){
  const count = grays.length;
  const sum = new Uint32Array(w * h);
  const sumSq = new Uint32Array(w * h);
  for (const g of grays) {
    for (let i = 0; i < g.length; i++) {
      const v = g[i];
      sum[i] += v;
      sumSq[i] += v * v;
    }
  }
  const mask = new Uint8Array(w * h);
  for (let i = 0; i < mask.length; i++) {
    const mean = sum[i] / count;
    const variance = (sumSq[i] / count) - (mean * mean);
    mask[i] = variance < OCR_COMMON_VAR_THRESHOLD ? 1 : 0;
  }
  return mask;
}

function applyMask(gray, mask){
  const out = new Uint8Array(gray.length);
  for (let i = 0; i < gray.length; i++) {
    out[i] = mask[i] ? 255 : gray[i];
  }
  return out;
}

function grayToCanvas(gray, w, h){
  const c = document.createElement("canvas");
  c.width = w;
  c.height = h;
  const ctx = c.getContext("2d");
  const img = ctx.createImageData(w, h);
  const d = img.data;
  for (let i = 0; i < gray.length; i++) {
    const v = gray[i];
    const p = i * 4;
    d[p] = d[p + 1] = d[p + 2] = v;
    d[p + 3] = 255;
  }
  ctx.putImageData(img, 0, 0);
  return c;
}

function cleanupDigits(text){
  // 数字以外は除去
  const m = (text || "").replace(/[^\d]/g, "");
  return m.length ? m : null;
}

async function ocrDigitsFromItem(maskedGray, w, h){
  await ensureOcrWorker();
  const maskedCanvas = grayToCanvas(maskedGray, w, h);
  const { canvas: bin, threshold } = binarizeFromGray(maskedGray, w, h);
  updateOcrDebug(maskedCanvas, bin, threshold);

  const { data } = await ocrWorker.recognize(bin);
  return cleanupDigits(data.text);
}

function updateOcrDebug(cropCanvas, binCanvas, threshold){
  drawDebugCanvas(ocrCropCanvas, cropCanvas);
  drawDebugCanvas(ocrBinCanvas, binCanvas);
  ocrThresholdLabel.textContent = threshold;
}

function drawDebugCanvas(target, source){
  const ctx = target.getContext("2d");
  target.width = source.width;
  target.height = source.height;
  ctx.clearRect(0, 0, target.width, target.height);
  ctx.drawImage(source, 0, 0);
}

// ---------- Frame Detection ----------
function detectFrames(){
  result.innerHTML="";
  itemsForOcr = [];
  const w=srcCanvas.width,h=srcCanvas.height;
  const scale=0.5;
  const sw=w*scale|0,sh=h*scale|0;

  const tmp=document.createElement("canvas");
  tmp.width=sw;tmp.height=sh;
  const tctx=tmp.getContext("2d");
  tctx.drawImage(srcCanvas,0,0,sw,sh);

  const img=tctx.getImageData(0,0,sw,sh);
  const g=new Uint8Array(sw*sh);
  for(let i=0;i<img.data.length;i+=4)
    g[i/4]=(img.data[i]+img.data[i+1]+img.data[i+2])/3;

  const edge=new Uint8Array(sw*sh);
  for(let y=1;y<sh;y++)for(let x=1;x<sw;x++){
    const i=y*sw+x;
    edge[i]=(Math.abs(g[i]-g[i-1])+Math.abs(g[i]-g[i-sw]))>25;
  }

  const v=new Uint8Array(sw*sh);
  for(let i=0;i<sw*sh;i++){
    if(edge[i]&&!v[i]){
      let minX=sw,minY=sh,maxX=0,maxY=0;
      const st=[i];v[i]=1;
      while(st.length){
        const p=st.pop(),x=p%sw,y=p/sw|0;
        minX=Math.min(minX,x);minY=Math.min(minY,y);
        maxX=Math.max(maxX,x);maxY=Math.max(maxY,y);
        for(const[dX,dY]of[[1,0],[-1,0],[0,1],[0,-1]]){
          const nx=x+dX,ny=y+dY,ni=ny*sw+nx;
          if(nx>=0&&ny>=0&&nx<sw&&ny<sh&&edge[ni]&&!v[ni]){
            v[ni]=1;st.push(ni);
          }
        }
      }
      const rw=maxX-minX,rh=maxY-minY;
      if(rw>40&&Math.abs(rw-rh)<10)
        createItem(minX,minY,rw,rh,scale);
    }
  }
  runOcrForGroups();
}

// ---------- Item UI ----------
function createItem(x,y,w,h,scale){
  const c=document.createElement("canvas");
  c.width=w/scale; c.height=h/scale;
  c.getContext("2d").drawImage(srcCanvas,x/scale,y/scale,w/scale,h/scale,0,0,c.width,c.height);

  const norm=normalize(c);
  const hash=aHash(norm);
  const itemName=identifyItem(hash);
  const color=sampleFrameColor(c);
  const rarity=identifyRarity(color);

  const wrap=document.createElement("div");
  wrap.className="item";
  wrap.appendChild(c);

  const label=document.createElement("div");
  label.className="label";
  label.textContent=`${itemName||"未登録"} / ${rarity||"?"} / OCR...`;
  wrap.appendChild(label);

  wrap.onclick=()=>{
    const mode=prompt("1:アイテム登録  2:レアリティ色登録","");
    if(mode==="1"){
      const n=prompt("アイテム名",itemName||"");
      if(n){itemDB[n]=hash;save();}
    }
    if(mode==="2"){
      const r=prompt("レアリティ\n"+RARITIES.join(","),"");
      if(RARITIES.includes(r)){
        rarityDB[r]=color; save();
      }
    }
    // 表示更新（OCR値は再実行しない。必要なら再OCRボタン化）
    label.textContent=`${identifyItem(hash)||"未登録"} / ${identifyRarity(color)||"?"} / (keep)`;
  };

  result.appendChild(wrap);
  itemsForOcr.push({ canvas: c, label, itemName, hash, rarity });
}

let itemsForOcr = [];

function runOcrForGroups(){
  const groups = new Map();
  for (const item of itemsForOcr) {
    const key = item.itemName || item.hash || "unknown";
    if (!groups.has(key)) groups.set(key, []);
    groups.get(key).push(item);
  }

  for (const group of groups.values()) {
    if (group.length === 0) continue;
    const prepared = group.map(item => ({ item, ...prepareOcrCanvas(item.canvas) }));
    const w = prepared[0].width;
    const h = prepared[0].height;
    const grays = prepared.map(p => p.gray);
    const mask = computeCommonMask(grays, w, h);

    for (const entry of prepared) {
      const maskedGray = applyMask(entry.gray, mask);
      enqueueOcr(async () => {
        const digits = await ocrDigitsFromItem(maskedGray, w, h);
        const { item } = entry;
        item.label.textContent = `${item.itemName||"未登録"} / ${item.rarity||"?"} / ${digits || "-"}`;
      });
    }
  }
}

// ---------- Save / View ----------
function save(){
  localStorage.setItem(ITEM_DB_KEY,JSON.stringify(itemDB));
  localStorage.setItem(RARITY_DB_KEY,JSON.stringify(rarityDB));
  updateDBView();
}

function updateDBView(){
  dbview.textContent=JSON.stringify({items:itemDB,rarity:rarityDB},null,2);
}
</script>
</body>
</html>
