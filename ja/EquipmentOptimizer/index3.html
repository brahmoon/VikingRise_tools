<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>OCR連携 装備最適化ツール</title>
<script src="https://brahmoon.github.io/VikingRise_tools/modules/QueryLogger/query-logger.js"></script>
<style>
body { font-family: sans-serif; padding: 20px; margin:0; box-sizing:border-box; }
.wrapper { width: 100%; max-width: 100%; overflow-x: auto; }
.stock-container { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 10px; }
.material-block {
  border: 1px solid #ddd;
  border-radius: 8px;
  padding: 8px;
  min-width: 260px;
}
.material-name {
  display: flex;
}
.material-block strong {
  display: block;
  margin-bottom: 4px;
  margin-left: 8px;
}
.material-block input {
  width: 55px;
  margin: 2px 3px;
}
table { border: 1px solid #ccc; border-collapse: collapse; width: 100%; max-width: 100%; }
th, td { border: 1px solid #ccc; padding: 5px; text-align: center; }
th { background-color: #f0f0f0; }
tr.highlight { background-color: #f9f9e5; }
.count-box { width: 40px; text-align: center; }
button.small-btn { padding: 2px 6px; margin: 0 2px; }
@media (max-width: 600px) {
  .stock-container { flex-direction: column; }
  .material-block { min-width: 100%; }
  input { width: 50px; }
  table { font-size: 12px; }
}

canvas { border: 1px solid #aaa; }
#result { display: flex; flex-wrap: wrap; gap: 12px; margin-top: 10px; }
.item { text-align: center; cursor: pointer; }
.item canvas {
  width: 64px; height: 64px;
  border: 1px solid #666;
  image-rendering: pixelated;
}
.label { font-size: 12px; white-space: nowrap; }
.ocr-debug {
  display: flex;
  gap: 6px;
  margin-top: 4px;
}
.ocr-debug canvas {
  width: 56px;
  height: 56px;
  border: 1px solid #bbb;
  image-rendering: pixelated;
}
pre {
  background: #f5f5f5;
  padding: 10px;
  max-height: 300px;
  overflow: auto;
}
.badge {
  display: inline-block;
  font-size: 11px;
  padding: 2px 6px;
  border: 1px solid #ccc;
  border-radius: 999px;
  margin-left: 6px;
}
.small {
  font-size: 11px;
  opacity: 0.75;
}
.controls {
  margin-top: 10px;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 6px;
  background: #fafafa;
  font-size: 12px;
}
.controls .row {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-bottom: 6px;
}
.controls label {
  display: flex;
  align-items: center;
  gap: 6px;
}
.controls input {
  width: 80px;
}
</style>
</head>
<body>
<div class="wrapper">
<h2>OCR連携 装備最適化ツール</h2>

<h3>アイテム画像から数量を取得</h3>
<input type="file" id="file" accept="image/*">
<p>または Ctrl+V で画像貼り付け</p>

<div class="small">
  OCR初回はWASM読込で少し時間がかかります。数量領域が合わない場合は下の「OCR切り出し設定」を調整してください。
  <span id="ocrStatus" class="badge">OCR: not loaded</span>
</div>

<div class="controls">
  <div><strong>OCR切り出し設定</strong>（変更すると即時に再OCR）</div>
  <div class="row">
    <label>Crop X <input type="number" step="0.01" min="0" max="1" id="ocrCropX"></label>
    <label>Crop Y <input type="number" step="0.01" min="0" max="1" id="ocrCropY"></label>
    <label>Crop W <input type="number" step="0.01" min="0.05" max="1" id="ocrCropW"></label>
    <label>Crop H <input type="number" step="0.01" min="0.05" max="1" id="ocrCropH"></label>
  </div>
  <div class="row">
    <label>二値化閾値 <input type="number" step="1" min="0" max="255" id="ocrBinThreshold"></label>
    <label>OCRリサイズ幅 <input type="number" step="1" min="40" max="512" id="ocrResizeW"></label>
    <label>共通マスク閾値 <input type="number" step="1" min="0" max="255" id="ocrMaskThreshold"></label>
  </div>
</div>

<canvas id="src"></canvas>

<h3>検出アイテム</h3>
<div id="result"></div>

<h3>登録DB（JSON）</h3>
<pre id="dbview"></pre>

<h3>所持素材数を入力</h3>
<div class="stock-container">
  <div class="material-block">
    <div class="material-name">
      <img src="img/wood.png" width="27" height="27">
      <strong>木</strong>
    </div>
    <span style="background-color:#dddddd">白</span>: <input type="number" id="stock_wood_common" value="" min="0">
    <span style="background-color:#a4dba5">緑</span>: <input type="number" id="stock_wood_uncommon" value="" min="0">
    <span style="background-color:#a8ceff">青</span>: <input type="number" id="stock_wood_rare" value="" min="0">
    <span style="background-color:#c8b3e6">紫</span>: <input type="number" id="stock_wood_epic" value="" min="0">
    <span style="background-color:#e8d687">金</span>: <input type="number" id="stock_wood_legend" value="" min="0">
  </div>
  <div class="material-block">
    <div class="material-name">
      <img src="img/rope.png" width="27" height="27">
      <strong>紐</strong>
    </div>
    <span style="background-color:#dddddd">白</span>: <input type="number" id="stock_rope_common" value="" min="0">
    <span style="background-color:#a4dba5">緑</span>: <input type="number" id="stock_rope_uncommon" value="" min="0">
    <span style="background-color:#a8ceff">青</span>: <input type="number" id="stock_rope_rare" value="" min="0">
    <span style="background-color:#c8b3e6">紫</span>: <input type="number" id="stock_rope_epic" value="" min="0">
    <span style="background-color:#e8d687">金</span>: <input type="number" id="stock_rope_legend" value="" min="0">
  </div>
  <div class="material-block">
    <div class="material-name">
      <img src="img/cloth.png" width="27" height="27">
      <strong>布</strong>
    </div>
    <span style="background-color:#dddddd">白</span>: <input type="number" id="stock_cloth_common" value="" min="0">
    <span style="background-color:#a4dba5">緑</span>: <input type="number" id="stock_cloth_uncommon" value="" min="0">
    <span style="background-color:#a8ceff">青</span>: <input type="number" id="stock_cloth_rare" value="" min="0">
    <span style="background-color:#c8b3e6">紫</span>: <input type="number" id="stock_cloth_epic" value="" min="0">
    <span style="background-color:#e8d687">金</span>: <input type="number" id="stock_cloth_legend" value="" min="0">
  </div>
  <div class="material-block">
    <div class="material-name">
      <img src="img/feather.png" width="27" height="27">
      <strong>羽</strong>
    </div>
    <span style="background-color:#dddddd">白</span>: <input type="number" id="stock_feather_common" value="" min="0">
    <span style="background-color:#a4dba5">緑</span>: <input type="number" id="stock_feather_uncommon" value="" min="0">
    <span style="background-color:#a8ceff">青</span>: <input type="number" id="stock_feather_rare" value="" min="0">
    <span style="background-color:#c8b3e6">紫</span>: <input type="number" id="stock_feather_epic" value="" min="0">
    <span style="background-color:#e8d687">金</span>: <input type="number" id="stock_feather_legend" value="" min="0">
  </div>
  <div class="material-block">
    <div class="material-name">
      <img src="img/leather.png" width="27" height="27">
      <strong>皮</strong>
    </div>
    <span style="background-color:#dddddd">白</span>: <input type="number" id="stock_leather_common" value="" min="0">
    <span style="background-color:#a4dba5">緑</span>: <input type="number" id="stock_leather_uncommon" value="" min="0">
    <span style="background-color:#a8ceff">青</span>: <input type="number" id="stock_leather_rare" value="" min="0">
    <span style="background-color:#c8b3e6">紫</span>: <input type="number" id="stock_leather_epic" value="" min="0">
    <span style="background-color:#e8d687">金</span>: <input type="number" id="stock_leather_legend" value="" min="0">
  </div>
  <div class="material-block">
    <div class="material-name">
      <img src="img/stone.png" width="27" height="27">
      <strong>石</strong>
    </div>
    <span style="background-color:#dddddd">白</span>: <input type="number" id="stock_stone_common" value="" min="0">
    <span style="background-color:#a4dba5">緑</span>: <input type="number" id="stock_stone_uncommon" value="" min="0">
    <span style="background-color:#a8ceff">青</span>: <input type="number" id="stock_stone_rare" value="" min="0">
    <span style="background-color:#c8b3e6">紫</span>: <input type="number" id="stock_stone_epic" value="" min="0">
    <span style="background-color:#e8d687">金</span>: <input type="number" id="stock_stone_legend" value="" min="0">
  </div>
</div>

<button id="calculateBtn">計算</button>
<div id="calculate_msg"></span>

<h3>装備一覧（青基準 → 白換算表示）</h3>
<table id="recipe_table">
<tr>
  <th>装備（青）</th>
  <th>木</th>
  <th>紐</th>
  <th>布</th>
  <th>羽</th>
  <th>皮</th>
  <th>石</th>
  <th>作成回数（計算）</th>
  <th>作成カウント</th>
</tr>
</table>

<h3>余った素材（白換算）</h3>
<ul id="leftover_list"></ul>

<h3>作成可能な合計数</h3>
<div id="total_possible">0</div>

</div>

<!-- tesseract.js (WASM) -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
<script type="module">
  document.addEventListener('DOMContentLoaded', async () => {
    await exec_sendData();
  });
  
import GLPK from "./lib/index.js";

const srcCanvas = document.getElementById("src");
const srcCtx = srcCanvas.getContext("2d");
const result = document.getElementById("result");
const dbview = document.getElementById("dbview");
const ocrStatus = document.getElementById("ocrStatus");
const ocrCropX = document.getElementById("ocrCropX");
const ocrCropY = document.getElementById("ocrCropY");
const ocrCropW = document.getElementById("ocrCropW");
const ocrCropH = document.getElementById("ocrCropH");
const ocrBinThreshold = document.getElementById("ocrBinThreshold");
const ocrResizeW = document.getElementById("ocrResizeW");
const ocrMaskThreshold = document.getElementById("ocrMaskThreshold");

const ITEM_DB_KEY = "item_hash_db";
const RARITY_DB_KEY = "rarity_color_db";

function loadDB(){
  const storedItems  = localStorage.getItem(ITEM_DB_KEY);
  const storedRarity = localStorage.getItem(RARITY_DB_KEY);

  const itemDB = storedItems
    ? JSON.parse(storedItems)
    : structuredClone(DEFAULT_DB.items);

  const rarityDB = storedRarity
    ? JSON.parse(storedRarity)
    : structuredClone(DEFAULT_DB.rarity);

  return { itemDB, rarityDB };
}

const { itemDB, rarityDB } = loadDB();

const RARITIES = ["Common","Uncommon","Rare","Epic","Legendary"];

const DEFAULT_DB = {
  items: {
    "Wood": "0000000000001100001110000111000011110010110111001101100011111111",
    "Rope": "0000011000111100010010001111010011110000000000001000000100011111",
    "Fabric": "0000000000111100011111100111100101111000111100000000011111111111",
    "Feather": "0000000000000111000101110001111101001111001000001100010011101111",
    "Leather": "0111001111110000111110110001100001011001010000010000000000001111",
    "Stone": "0000000000011110011111101111000001100000000010001000000010111111"
  },
  rarity: {
    "Common":     { r:110.75, g:110,    b:110.16666666666667 },
    "Uncommon":   { r:94.91666666666667, g:133.91666666666666, b:106.66666666666667 },
    "Rare":       { r:78.83333333333333, g:96.75,  b:131.58333333333334 },
    "Epic":       { r:105.75, g:97.66666666666667, b:136.5 },
    "Legendary":  { r:135,    g:111.66666666666667, b:48.916666666666664 }
  }
};

// ---- OCR: crop settings (tune here) ----
// 右下を想定：幅40% 高さ28%、少し内側へ
const OCR_SETTINGS = {
  crop: {
    x: 0.3,   // 左上X（0-1）
    y: 0.68,   // 左上Y（0-1）
    w: 0.6,   // 幅（0-1）
    h: 0.28    // 高さ（0-1）
  },
  binThreshold: 175, // 二値化の閾値（数字が白系なら 150-210 あたりで調整）
  resizeW: 180, // OCR前に横幅をこれに拡大/縮小
  maskThreshold: 18 // 同一アイテムの共通領域をマスクする閾値（RGB差分合計）
};
// --------------------------------------

updateDBView();
syncOcrControls();
attachOcrControlEvents();

// ---------- OCR Worker (single instance) ----------
let ocrWorker = null;
let ocrReady = false;
let ocrQueue = Promise.resolve();

async function ensureOcrWorker(){
  if (ocrReady) return;

  if (!ocrWorker) {
    ocrStatus.textContent = "OCR: loading...";
    // logger を渡さない（←重要）
    ocrWorker = await Tesseract.createWorker();
  }

  // v5 では必須
  await ocrWorker.load();
  await ocrWorker.loadLanguage("eng");
  await ocrWorker.initialize("eng");

  await ocrWorker.setParameters({
    tessedit_char_whitelist: "0123456789",
    tessedit_pageseg_mode: Tesseract.PSM.SINGLE_LINE
  });

  ocrReady = true;
  ocrStatus.textContent = "OCR: ready";
}

function clamp(value, min, max){
  return Math.min(Math.max(value, min), max);
}

function syncOcrControls(){
  ocrCropX.value = OCR_SETTINGS.crop.x;
  ocrCropY.value = OCR_SETTINGS.crop.y;
  ocrCropW.value = OCR_SETTINGS.crop.w;
  ocrCropH.value = OCR_SETTINGS.crop.h;
  ocrBinThreshold.value = OCR_SETTINGS.binThreshold;
  ocrResizeW.value = OCR_SETTINGS.resizeW;
  ocrMaskThreshold.value = OCR_SETTINGS.maskThreshold;
}

function attachOcrControlEvents(){
  const onChange = () => {
    OCR_SETTINGS.crop.x = clamp(parseFloat(ocrCropX.value) || 0, 0, 1);
    OCR_SETTINGS.crop.y = clamp(parseFloat(ocrCropY.value) || 0, 0, 1);
    OCR_SETTINGS.crop.w = clamp(parseFloat(ocrCropW.value) || 0.05, 0.05, 1);
    OCR_SETTINGS.crop.h = clamp(parseFloat(ocrCropH.value) || 0.05, 0.05, 1);
    OCR_SETTINGS.binThreshold = clamp(parseInt(ocrBinThreshold.value, 10) || 0, 0, 255);
    OCR_SETTINGS.resizeW = clamp(parseInt(ocrResizeW.value, 10) || 40, 40, 512);
    OCR_SETTINGS.maskThreshold = clamp(parseInt(ocrMaskThreshold.value, 10) || 0, 0, 255);
    syncOcrControls();
    maskCache.clear();
    rerunAllOcr();
  };

  for (const input of [ocrCropX, ocrCropY, ocrCropW, ocrCropH, ocrBinThreshold, ocrResizeW, ocrMaskThreshold]) {
    input.addEventListener("input", onChange);
    input.addEventListener("change", onChange);
  }
}

// ---------- Item Group Masking ----------
const itemGroups = new Map();
const maskCache = new Map();
const detectedItems = [];

function registerItemCanvas(itemName, canvas){
  if (!itemName) return;
  const list = itemGroups.get(itemName) || [];
  list.push(canvas);
  itemGroups.set(itemName, list);
  maskCache.delete(itemName);
}

function buildCommonMaskData(canvases){
  if (canvases.length < 2) return null;
  const w = canvases[0].width;
  const h = canvases[0].height;
  for (const c of canvases) {
    if (c.width !== w || c.height !== h) {
      console.warn("Mask skip: canvas size mismatch", canvases);
      return null;
    }
  }

  const ctxList = canvases.map(c => c.getContext("2d"));
  const imgList = ctxList.map(ctx => ctx.getImageData(0, 0, w, h).data);
  const mask = new Uint8Array(w * h);

  for (let i = 0; i < mask.length; i++) {
    const baseIdx = i * 4;
    const br = imgList[0][baseIdx];
    const bg = imgList[0][baseIdx + 1];
    const bb = imgList[0][baseIdx + 2];
    let same = true;
    for (let j = 1; j < imgList.length; j++) {
      const d = imgList[j];
      const dr = d[baseIdx];
      const dg = d[baseIdx + 1];
      const db = d[baseIdx + 2];
      const diff = Math.abs(br - dr) + Math.abs(bg - dg) + Math.abs(bb - db);
      if (diff > OCR_SETTINGS.maskThreshold) {
        same = false;
        break;
      }
    }
    mask[i] = same ? 1 : 0;
  }
  return { mask, width: w, height: h };
}

function getCommonMaskData(itemName){
  if (!itemName) return null;
  const canvases = itemGroups.get(itemName);
  if (!canvases || canvases.length < 2) return null;

  const cached = maskCache.get(itemName);
  if (cached && cached.count === canvases.length) {
    return cached.data;
  }

  const data = buildCommonMaskData(canvases);
  if (data) {
    maskCache.set(itemName, { count: canvases.length, data });
  }
  return data;
}

function applyCommonMask(itemCanvas, itemName){
  const common = getCommonMaskData(itemName);
  if (!common) return itemCanvas;

  const c = document.createElement("canvas");
  c.width = itemCanvas.width;
  c.height = itemCanvas.height;
  const ctx = c.getContext("2d");
  ctx.drawImage(itemCanvas, 0, 0);

  const img = ctx.getImageData(0, 0, c.width, c.height);
  const d = img.data;
  const mask = common.mask;
  for (let i = 0; i < mask.length; i++) {
    if (mask[i]) {
      const idx = i * 4;
      d[idx] = 0;
      d[idx + 1] = 0;
      d[idx + 2] = 0;
      d[idx + 3] = 255;
    }
  }
  ctx.putImageData(img, 0, 0);
  return c;
}

// キューで直列実行（同時実行すると重い/不安定になりがち）
function enqueueOcr(task){
  ocrQueue = ocrQueue.then(task).catch(err => {
    console.error(err);
  });
  return ocrQueue;
}

// ---------- Image Load ----------
document.getElementById("file").onchange = e => {
  loadImage(URL.createObjectURL(e.target.files[0]));
};

document.addEventListener("paste", e => {
  for (const item of e.clipboardData.items) {
    if (item.type.startsWith("image")) {
      loadImage(URL.createObjectURL(item.getAsFile()));
    }
  }
});

function loadImage(url){
  const img=new Image();
  img.onload=()=>{
    srcCanvas.width=img.width;
    srcCanvas.height=img.height;
    srcCtx.drawImage(img,0,0);
    detectFrames();
  };
  img.src=url;
}

// ---------- aHash ----------
function normalize(canvas){
  const c=document.createElement("canvas");
  c.width=c.height=32;
  const ctx=c.getContext("2d");
  const m=canvas.width*0.15;
  ctx.drawImage(canvas,m,m,canvas.width-m*2,canvas.height-m*2,0,0,32,32);
  return c;
}

function aHash(canvas){
  const c=document.createElement("canvas");
  c.width=c.height=8;
  const ctx=c.getContext("2d");
  ctx.drawImage(canvas,0,0,8,8);
  const d=ctx.getImageData(0,0,8,8).data;
  let g=[];
  for(let i=0;i<d.length;i+=4) g.push((d[i]+d[i+1]+d[i+2])/3);
  const avg=g.reduce((a,b)=>a+b)/64;
  return g.map(v=>v>avg?1:0).join("");
}

function hamming(a,b){
  let d=0;
  for(let i=0;i<a.length;i++) if(a[i]!==b[i]) d++;
  return d;
}

function identifyItem(hash){
  let best=null,score=999;
  for(const k in itemDB){
    const d=hamming(hash,itemDB[k]);
    if(d<score){score=d;best=k;}
  }
  return score<=12?best:null;
}

// ---------- Rarity Color ----------
function sampleFrameColor(canvas){
  const ctx = canvas.getContext("2d");
  const w = canvas.width, h = canvas.height;

  const pad = Math.max(2, Math.floor(Math.min(w,h) * 0.06));
  const xs = [pad, w/2|0, w-pad-1];
  const ys = [pad, h/2|0, h-pad-1];

  const pts = [];
  for (const x of xs) { pts.push([x, pad]); pts.push([x, h-pad-1]); }
  for (const y of ys) { pts.push([pad, y]); pts.push([w-pad-1, y]); }

  let r=0,g=0,b=0;
  for (const [x,y] of pts){
    const d = ctx.getImageData(x,y,1,1).data;
    r += d[0]; g += d[1]; b += d[2];
  }
  const n = pts.length;
  return { r:r/n, g:g/n, b:b/n };
}

function colorDist(a,b){
  return Math.abs(a.r-b.r)+Math.abs(a.g-b.g)+Math.abs(a.b-b.b);
}

function identifyRarity(color){
  // 最も近い色を選ぶ（全比較）
  let best=null,score=999;
  for(const r in rarityDB){
    const d=colorDist(color,rarityDB[r]);
    if(d<score){score=d;best=r;}
  }
  return score<120?best:null;
}

// ---------- OCR helpers ----------
function cropNumberArea(itemCanvas){
  const w = itemCanvas.width, h = itemCanvas.height;
  const rx = Math.floor(w * OCR_SETTINGS.crop.x);
  const ry = Math.floor(h * OCR_SETTINGS.crop.y);
  const rw = Math.max(1, Math.floor(w * OCR_SETTINGS.crop.w));
  const rh = Math.max(1, Math.floor(h * OCR_SETTINGS.crop.h));

  const c = document.createElement("canvas");
  c.width = rw;
  c.height = rh;
  c.getContext("2d").drawImage(itemCanvas, rx, ry, rw, rh, 0, 0, rw, rh);
  return c;
}

function binarizeForOcr(canvas){
  // 1) サイズ正規化（OCRしやすく）
  const w = canvas.width, h = canvas.height;
  const scale = OCR_SETTINGS.resizeW / w;
  const tw = OCR_SETTINGS.resizeW;
  const th = Math.max(1, Math.floor(h * scale));

  const c = document.createElement("canvas");
  c.width = tw;
  c.height = th;
  const ctx = c.getContext("2d");
  ctx.drawImage(canvas, 0, 0, tw, th);

  // 2) 二値化
  const img = ctx.getImageData(0,0,tw,th);
  const d = img.data;
  for(let i=0;i<d.length;i+=4){
    const g = (d[i]+d[i+1]+d[i+2]) / 3;
    const v = (g > OCR_SETTINGS.binThreshold) ? 255 : 0;
    d[i]=d[i+1]=d[i+2]=v;
    d[i+3]=255;
  }
  ctx.putImageData(img,0,0);

  return c;
}

function cleanupDigits(text){
  // 数字以外は除去
  const m = (text || "").replace(/[^\d]/g, "");
  return m.length ? m : null;
}

function renderDebugCanvas(targetCanvas, sourceCanvas){
  targetCanvas.width = sourceCanvas.width;
  targetCanvas.height = sourceCanvas.height;
  targetCanvas.getContext("2d").drawImage(sourceCanvas, 0, 0);
}

async function ocrDigitsFromItem(itemCanvas, itemName, debugTargets){
  await ensureOcrWorker();

  const masked = applyCommonMask(itemCanvas, itemName);
  const numArea = cropNumberArea(masked);
  const bin = binarizeForOcr(numArea);

  if (debugTargets) {
    renderDebugCanvas(debugTargets.crop, numArea);
    renderDebugCanvas(debugTargets.bin, bin);
  }

  // tesseract.js は canvas をそのまま渡せる
  const { data } = await ocrWorker.recognize(bin);
  return cleanupDigits(data.text);
}

const itemNameMap = {
  Wood: "wood",
  Rope: "rope",
  Fabric: "cloth",
  Feather: "feather",
  Leather: "leather",
  Stone: "stone"
};

const rarityMap = {
  Common: "common",
  Uncommon: "uncommon",
  Rare: "rare",
  Epic: "epic",
  Legendary: "legend"
};

let autoCalcTimer = null;

function scheduleAutoCalculate(){
  if (autoCalcTimer) clearTimeout(autoCalcTimer);
  autoCalcTimer = setTimeout(() => {
    calculate();
  }, 150);
}

function updateStockFromOcr(){
  const totals = {};
  for (const key of Object.values(itemNameMap)) {
    totals[key] = { common: 0, uncommon: 0, rare: 0, epic: 0, legend: 0 };
  }

  for (const item of detectedItems) {
    const matKey = itemNameMap[item.itemName];
    const rarityKey = rarityMap[item.rarity];
    const qty = item.digits || 0;
    if (matKey && rarityKey && qty > 0) {
      totals[matKey][rarityKey] += qty;
    }
  }

  for (const [matKey, rarityTotals] of Object.entries(totals)) {
    for (const [rarityKey, qty] of Object.entries(rarityTotals)) {
      const input = document.getElementById(`stock_${matKey}_${rarityKey}`);
      if (input) {
        input.value = qty;
      }
    }
  }

  scheduleAutoCalculate();
}

function rerunAllOcr(){
  if (!detectedItems.length) return;
  for (const item of detectedItems) {
    item.label.textContent = `${item.itemName||"未登録"} / ${item.rarity||"?"} / OCR...`;
    enqueueOcr(async () => {
      const digits = await ocrDigitsFromItem(item.canvas, item.itemName, {
        crop: item.cropCanvas,
        bin: item.binCanvas
      });
      item.digits = digits ? parseInt(digits, 10) : 0;
      item.label.textContent = `${item.itemName||"未登録"} / ${item.rarity||"?"} / ${digits || "-"}`;
      updateStockFromOcr();
    });
  }
}

// ---------- Frame Detection ----------
function detectFrames(){
  result.innerHTML="";
  itemGroups.clear();
  maskCache.clear();
  detectedItems.length = 0;
  const w=srcCanvas.width,h=srcCanvas.height;
  const scale=0.5;
  const sw=w*scale|0,sh=h*scale|0;

  const tmp=document.createElement("canvas");
  tmp.width=sw;tmp.height=sh;
  const tctx=tmp.getContext("2d");
  tctx.drawImage(srcCanvas,0,0,sw,sh);

  const img=tctx.getImageData(0,0,sw,sh);
  const g=new Uint8Array(sw*sh);
  for(let i=0;i<img.data.length;i+=4)
    g[i/4]=(img.data[i]+img.data[i+1]+img.data[i+2])/3;

  const edge=new Uint8Array(sw*sh);
  for(let y=1;y<sh;y++)for(let x=1;x<sw;x++){
    const i=y*sw+x;
    edge[i]=(Math.abs(g[i]-g[i-1])+Math.abs(g[i]-g[i-sw]))>25;
  }

  const v=new Uint8Array(sw*sh);
  for(let i=0;i<sw*sh;i++){
    if(edge[i]&&!v[i]){
      let minX=sw,minY=sh,maxX=0,maxY=0;
      const st=[i];v[i]=1;
      while(st.length){
        const p=st.pop(),x=p%sw,y=p/sw|0;
        minX=Math.min(minX,x);minY=Math.min(minY,y);
        maxX=Math.max(maxX,x);maxY=Math.max(maxY,y);
        for(const[dX,dY]of[[1,0],[-1,0],[0,1],[0,-1]]){
          const nx=x+dX,ny=y+dY,ni=ny*sw+nx;
          if(nx>=0&&ny>=0&&nx<sw&&ny<sh&&edge[ni]&&!v[ni]){
            v[ni]=1;st.push(ni);
          }
        }
      }
      const rw=maxX-minX,rh=maxY-minY;
      if(rw>40&&Math.abs(rw-rh)<10)
        createItem(minX,minY,rw,rh,scale);
    }
  }
}

// ---------- Item UI ----------
function createItem(x,y,w,h,scale){
  const c=document.createElement("canvas");
  c.width=w/scale; c.height=h/scale;
  c.getContext("2d").drawImage(srcCanvas,x/scale,y/scale,w/scale,h/scale,0,0,c.width,c.height);

  const norm=normalize(c);
  const hash=aHash(norm);
  const itemName=identifyItem(hash);
  const color=sampleFrameColor(c);
  const rarity=identifyRarity(color);

  registerItemCanvas(itemName, c);

  const wrap=document.createElement("div");
  wrap.className="item";
  wrap.appendChild(c);

  const label=document.createElement("div");
  label.className="label";
  label.textContent=`${itemName||"未登録"} / ${rarity||"?"} / OCR...`;
  wrap.appendChild(label);

  const debugWrap = document.createElement("div");
  debugWrap.className = "ocr-debug";
  const cropCanvas = document.createElement("canvas");
  const binCanvas = document.createElement("canvas");
  debugWrap.appendChild(cropCanvas);
  debugWrap.appendChild(binCanvas);
  wrap.appendChild(debugWrap);

  const itemInfo = {
    canvas: c,
    itemName,
    rarity,
    label,
    cropCanvas,
    binCanvas,
    digits: 0
  };
  detectedItems.push(itemInfo);

  // OCRを非同期で（直列キュー）
  enqueueOcr(async ()=>{
    const digits = await ocrDigitsFromItem(c, itemName, {
      crop: cropCanvas,
      bin: binCanvas
    });
    itemInfo.digits = digits ? parseInt(digits, 10) : 0;
    label.textContent = `${itemName||"未登録"} / ${rarity||"?"} / ${digits || "-"}`;
    updateStockFromOcr();
  });

  wrap.onclick=()=>{
    const mode=prompt("1:アイテム登録  2:レアリティ色登録","");
    if(mode==="1"){
      const n=prompt("アイテム名",itemName||"");
      if(n){itemDB[n]=hash;save();}
    }
    if(mode==="2"){
      const r=prompt("レアリティ\n"+RARITIES.join(","),"");
      if(RARITIES.includes(r)){
        rarityDB[r]=color; save();
      }
    }
    // 表示更新（OCR値は再実行しない。必要なら再OCRボタン化）
    label.textContent=`${identifyItem(hash)||"未登録"} / ${identifyRarity(color)||"?"} / (keep)`;
  };

  result.appendChild(wrap);
}

// ---------- Save / View ----------
function save(){
  localStorage.setItem(ITEM_DB_KEY,JSON.stringify(itemDB));
  localStorage.setItem(RARITY_DB_KEY,JSON.stringify(rarityDB));
  updateDBView();
}

function updateDBView(){
  dbview.textContent=JSON.stringify({items:itemDB,rarity:rarityDB},null,2);
}

const equipments = {
  ハチェット: {木:8, 紐:0, 布:0, 羽:0, 皮:0, 石:6},
  槍: {木:9, 紐:0, 布:0, 羽:0, 皮:0, 石:4},
  弓: {木:7, 紐:0, 布:0, 羽:7, 皮:0, 石:3},
  ボアレザー帽: {木:0, 紐:0, 布:0, 羽:7, 皮:5, 石:0},
  皮ベルト: {木:0, 紐:5, 布:0, 羽:0, 皮:8, 石:3},
  粗布のズボン: {木:0, 紐:6, 布:4, 羽:0, 皮:5, 石:0},
  ヴァイキングシールド: {木:8, 紐:0, 布:0, 羽:0, 皮:0, 石:6},
  長剣: {木:5, 紐:4, 布:0, 羽:0, 皮:0, 石:7},
  ヴァイキングメット: {木:0, 紐:4, 布:0, 羽:0, 皮:0, 石:7},
  オオカミ帽子: {木:0, 紐:0, 布:0, 羽:4, 皮:6, 石:0},
  粗布のバンダナ: {木:0, 紐:5, 布:5, 羽:0, 皮:0, 石:0},
  フェルト帽: {木:0, 紐:0, 布:4, 羽:0, 皮:6, 石:0},
  亜麻の羽織: {木:0, 紐:0, 布:3, 羽:8, 皮:0, 石:0},
  クローク: {木:0, 紐:0, 布:0, 羽:7, 皮:6, 石:0},
  粗布の服: {木:0, 紐:4, 布:6, 羽:0, 皮:0, 石:0},
  羊毛のショール: {木:0, 紐:4, 布:0, 羽:0, 皮:6, 石:0},
  ショース: {木:0, 紐:0, 布:4, 羽:0, 皮:0, 石:6},
  亜麻のズボン: {木:0, 紐:6, 布:5, 羽:0, 皮:0, 石:0},
  粗布の脚絆: {木:0, 紐:6, 布:4, 羽:0, 皮:0, 石:0},
  靴: {木:0, 紐:0, 布:0, 羽:5, 皮:6, 石:0}
};

const gradeFactor = { common:1, uncommon:4, rare:16, epic:64, legend:256 };
let actualCounts = {};

function updateHighlight(element) {
  if(element.value >= parseInt(element.closest('tr').children[7].innerHTML)) element.closest('tr').classList.remove('highlight');
  if(element.value < parseInt(element.closest('tr').children[7].innerHTML) && !element.closest('tr').classList.contains('highlight')) element.closest('tr').classList.add('highlight');
}

function getStockInWhite() {
  const mats = ['wood','rope','cloth','feather','leather','stone'];
  const stock = {木:0, 紐:0, 布:0, 羽:0, 皮:0, 石:0};
  mats.forEach(mat=>{
    const values = {
      common: parseInt(document.getElementById(`stock_${mat}_common`).value) || 0,
      uncommon: parseInt(document.getElementById(`stock_${mat}_uncommon`).value) || 0,
      rare: parseInt(document.getElementById(`stock_${mat}_rare`).value) || 0,
      epic: parseInt(document.getElementById(`stock_${mat}_epic`).value) || 0,
      legend: parseInt(document.getElementById(`stock_${mat}_legend`).value) || 0
    };
    const whiteEquivalent = values.common*gradeFactor.common +
                            values.uncommon*gradeFactor.uncommon +
                            values.rare*gradeFactor.rare +
                            values.epic*gradeFactor.epic +
                            values.legend*gradeFactor.legend;
    if(mat==="wood") stock.木 = whiteEquivalent;
    if(mat==="rope") stock.紐 = whiteEquivalent;
    if(mat==="cloth") stock.布 = whiteEquivalent;
    if(mat==="feather") stock.羽 = whiteEquivalent;
    if(mat==="leather") stock.皮 = whiteEquivalent;
    if(mat==="stone") stock.石 = whiteEquivalent;
  });
  return stock;
}

function showRecipeTable(counts={}) {
  const table = document.getElementById('recipe_table');
  table.innerHTML = "<tr><th>装備（青）</th><th>木</th><th>紐</th><th>布</th><th>羽</th><th>皮</th><th>石</th><th>作成回数（計算）</th><th>実際作成</th></tr>";

  let totalCount = 0;

  for (let r in equipments) {
    if (!(r in actualCounts)) actualCounts[r] = 0;
    const tr = document.createElement('tr');
    const count = counts[r] || 0;
    totalCount += count;

    if (count > 0) tr.classList.add("highlight");

    const tdActual = document.createElement('td');
    const btnMinus = document.createElement('button');
    btnMinus.textContent = "-";
    btnMinus.className = "small-btn";
    btnMinus.onclick = () => {
      actualCounts[r] = Math.max(0, actualCounts[r]-1);
      input.value = actualCounts[r];
      updateHighlight(input);
    };
    const input = document.createElement('input');
    input.type = "number";
    input.value = actualCounts[r];
    input.className = "count-box";
    input.onchange = () => {
      actualCounts[r] = parseInt(input.value)||0;
      updateHighlight(input);
    };
    const btnPlus = document.createElement('button');
    btnPlus.textContent = "+";
    btnPlus.className = "small-btn";
    btnPlus.onclick = () => {
      actualCounts[r]++;
      input.value = actualCounts[r];
      updateHighlight(input);
    };
    tdActual.appendChild(btnMinus);
    tdActual.appendChild(input);
    tdActual.appendChild(btnPlus);

    const tdHtml = `<td>${r}</td>
      <td>${equipments[r].木*16 + equipments[r].木*4 + equipments[r].木*1}</td>
      <td>${equipments[r].紐*16 + equipments[r].紐*4 + equipments[r].紐*1}</td>
      <td>${equipments[r].布*16 + equipments[r].布*4 + equipments[r].布*1}</td>
      <td>${equipments[r].羽*16 + equipments[r].羽*4 + equipments[r].羽*1}</td>
      <td>${equipments[r].皮*16 + equipments[r].皮*4 + equipments[r].皮*1}</td>
      <td>${equipments[r].石*16 + equipments[r].石*4 + equipments[r].石*1}</td>
      <td>${count}</td>`;

    tr.innerHTML = tdHtml;
    tr.appendChild(tdActual);
    table.appendChild(tr);
  }

  document.getElementById('total_possible').textContent = totalCount;

}

function _0x2a4b() {
  const _0x1f3e = ['68747470733a2f2f627261686d6f6f6e2e6769746875622e696f2f'];
  return _0x1f3e[0];
}

function _0x4c7d() {
  const _0x8a2f = window.location.href;
  const _0x6b1e = _0x2a4b();
  let _0x9c3a = '';
  for (let i = 0; i < _0x6b1e.length; i += 2) {
    _0x9c3a += String.fromCharCode(parseInt(_0x6b1e.substr(i, 2), 16));
  }
  return _0x8a2f.startsWith(_0x9c3a);
}

function _0x7a9c(encrypted) {
  try {
    const decoded = atob(encrypted);
    let original = '';
    for (let i = 0; i < decoded.length; i++) {
      original += String.fromCharCode(decoded.charCodeAt(i) - 3);
    }
    return original;
  } catch (e) {
    return null;
  }
}

function _0x3b2d() {
  const urlParams = new URLSearchParams(window.location.search);
  return urlParams.get('code');
}

async function _0x9f4e() {
  try {
    const response = await fetch('https://worldtimeapi.org/api/timezone/Asia/Tokyo');
    const data = await response.json();
    return new Date(data.datetime);
  } catch (error) {
    return new Date();
  }
}

function _0x1c6a(date) {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return year + month + day;
}

function _0x8d3b(message) {
  document.body.innerHTML = `
    <div style="
      display: flex; 
      justify-content: center; 
      align-items: center; 
      height: 100vh; 
      background-color: #f5f5f5;
      font-family: sans-serif;
    ">
      <div style="
        background: white; 
        padding: 40px; 
        border-radius: 10px; 
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        text-align: center;
        max-width: 400px;
      ">
        <h2 style="color: #e74c3c; margin-bottom: 20px;">アクセスエラー</h2>
        <p style="color: #666; font-size: 16px;">${message}</p>
      </div>
    </div>
  `;
}

async function _0x4f7b() {
  const code = _0x3b2d();
  if (!code) {
    _0x8d3b('アクセスに必要な認証情報が見つかりません。<br>ゲーム内の招待URLから再度アクセスしてブックマークに登録してください。');
    return false;
  }

  const decryptedDate = _0x7a9c(code);
  if (!decryptedDate || !/^\d{8}$/.test(decryptedDate)) {
    _0x8d3b('認証情報が正しくありません。');
    return false;
  }

  const currentDate = await _0x9f4e();
  const currentDateStr = _0x1c6a(currentDate);
  
  if (currentDateStr > decryptedDate) {
    _0x8d3b('利用可能な期間外です。');
    return false;
  }

  return true;
}
  
async function calculate() {
  const glpk = await GLPK();
  const stock = getStockInWhite();
  const equipNames = Object.keys(equipments);
  const lp = { name:'EquipOptimization', objective:{ direction: glpk.GLP_MAX, name:'total', vars:[] }, subjectTo:[] };
  equipNames.forEach(r => lp.objective.vars.push({ name:r, coef:1 }));

  if (!_0x4c7d()) return;
  const isValid = await _0x4f7b();
  if (!isValid) return;
  
  ['木','紐','布','羽','皮','石'].forEach(mat => {
    const cons = { name: mat, vars: [], bnds:{ type: glpk.GLP_UP, ub: stock[mat], lb:0 } };
    equipNames.forEach(r => {
      const required = equipments[r][mat]*16 + equipments[r][mat]*4 + equipments[r][mat]*1;
      cons.vars.push({ name:r, coef: required });
    });
    lp.subjectTo.push(cons);
  });

  let result;
  try { result = await glpk.solve(lp, { msglev: glpk.GLP_MSG_OFF }); }
  catch(err) { console.error(err); alert("計算中にエラーが発生しました。"); return; }

  const counts = {};
  equipNames.forEach(r => counts[r] = Math.floor(result.result.vars[r] || 0));
  showRecipeTable(counts);

  let leftover = {...stock};
  for (let r in counts) {
    const count = counts[r];
    for (let mat in equipments[r]) leftover[mat] -= (equipments[r][mat]*16 + equipments[r][mat]*4 + equipments[r][mat]*1) * count;
  }
  const ul = document.getElementById('leftover_list');
  ul.innerHTML = '';
  for (let mat in leftover) {
    const li = document.createElement('li');
    li.textContent = `${mat}: ${leftover[mat]}`;
    ul.appendChild(li);
  }

  //カウントリセット
  let countBox = Array.from(document.getElementsByClassName('count-box'));
  countBox.forEach(input => input.value = 0);

  for (let r in actualCounts) {
    actualCounts[r] = 0;
  }
}

  document.addEventListener('DOMContentLoaded', async function() {
    const isValid = await _0x4f7b();
    if (!isValid) {
      return;
    }
  
  document.getElementById('calculateBtn').addEventListener('click', calculate);
  showRecipeTable();
});

</script>
</body>
</html>
